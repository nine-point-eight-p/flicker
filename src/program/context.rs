use std::collections::HashMap;

use ahash::RandomState;
use uuid::Uuid;

use super::{
    call::Call,
    metadata::SyscallMetadata,
    syscall::{Syscall, Type},
};

pub struct Context {
    /// Metadata of syscalls
    metadata: SyscallMetadata,
    /// Result values generated by existing calls
    results: HashMap<Uuid, Type, RandomState>,
    /// Whether a resource is being generated
    pub generating_resource: bool,
}

impl Context {
    pub fn new(metadata: SyscallMetadata) -> Self {
        let hash_builder = RandomState::with_seeds(0, 0, 0, 0);
        Self {
            metadata,
            generating_resource: false,
            results: HashMap::with_hasher(hash_builder),
        }
    }

    pub fn with_calls(metadata: SyscallMetadata, calls: &[Call]) -> Self {
        let syscall_return_types: HashMap<u32, &Type, RandomState> = HashMap::from_iter(
            metadata
                .syscalls()
                .iter()
                .filter_map(|s| s.return_type().map(|ty| (s.number(), ty))),
        );
        let results = HashMap::from_iter(calls.iter().filter_map(|call| {
            call.result()
                .map(|id| (id, syscall_return_types[&call.number()].clone()))
        }));

        Self {
            metadata,
            generating_resource: false,
            results,
        }
    }

    pub fn syscalls(&self) -> &[Syscall] {
        self.metadata.syscalls()
    }

    pub fn results(&self) -> impl Iterator<Item = (&Uuid, &Type)> {
        self.results.iter()
    }

    pub fn add_result(&mut self, ty: &Type) -> Uuid {
        let id = Uuid::new_v4();
        self.results.insert(id, ty.clone());
        id
    }
}
